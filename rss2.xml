<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>개발괴발</title>
    <link>https://rvnkcode.github.io/</link>
    
    <atom:link href="https://rvnkcode.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>이번 블로그는 또 얼마나 갈까</description>
    <pubDate>Mon, 25 Apr 2022 12:54:56 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>언어의 타입 시스템과 컴파일러, 인터프리터</title>
      <link>https://rvnkcode.github.io/2022/04/22/3_typeSystemOfLang/</link>
      <guid>https://rvnkcode.github.io/2022/04/22/3_typeSystemOfLang/</guid>
      <pubDate>Fri, 22 Apr 2022 11:32:37 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;Backstory&quot;&gt;&lt;a href=&quot;#Backstory&quot; class=&quot;headerlink&quot; title=&quot;Backstory&quot;&gt;&lt;/a&gt;Backstory&lt;/h2&gt;&lt;p&gt;트위터에서 공유된 &lt;a href=&quot;https://ui.toast.com/weekly-pick/ko_20220127&quot;&gt;차세대 빌드 도구 비교&lt;/a&gt;라는 글을 읽다 본문에 언급된 esbuild나 vite는 커녕&lt;br&gt;컴파일과 빌드에 대한 개념, 번들러는 도대체 무슨 일을 하는 건지에 대한 이해가 없어 글을 이해할 수 없다는 걸 깨달았다.&lt;br&gt;트위터에서 이런 개념들에 대해 혼자 떠들다가 결국 영상 편집은 코딩이구나! 하는 인사이트를 얻었으니 좋은 계기였다고 생각한다.  &lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="Backstory"><a href="#Backstory" class="headerlink" title="Backstory"></a>Backstory</h2><p>트위터에서 공유된 <a href="https://ui.toast.com/weekly-pick/ko_20220127">차세대 빌드 도구 비교</a>라는 글을 읽다 본문에 언급된 esbuild나 vite는 커녕<br>컴파일과 빌드에 대한 개념, 번들러는 도대체 무슨 일을 하는 건지에 대한 이해가 없어 글을 이해할 수 없다는 걸 깨달았다.<br>트위터에서 이런 개념들에 대해 혼자 떠들다가 결국 영상 편집은 코딩이구나! 하는 인사이트를 얻었으니 좋은 계기였다고 생각한다.  </p><span id="more"></span><h2 id="자연어-프로그래밍-언어-어셈블리어-기계어"><a href="#자연어-프로그래밍-언어-어셈블리어-기계어" class="headerlink" title="자연어, 프로그래밍 언어, 어셈블리어, 기계어"></a>자연어, 프로그래밍 언어, 어셈블리어, 기계어</h2><blockquote><p>“역사가와 역사적 사실은 서로에게 필수적이다.<br>자신의 사실을 갖지 못한 역사가는 뿌리가 없는 쓸모없는 존재다.<br>자신의 역사가를 갖지 못한 사실은 죽은 것이며 무의미한 것이다.<br>역사란, 역사가와 그의 사실들의 지속적인 상호작용의 과정이며, 현재와 과거의 끊임없는 대화다<br>(a continuous process of interaction the historian and his facts, an unending dialogue between the present and the past).”<br>『역사란 무엇인가』(E.H.Carr 저, 김택현 옮김, 까치, p.50)</p></blockquote><h3 id="사람의-언어"><a href="#사람의-언어" class="headerlink" title="사람의 언어"></a>사람의 언어</h3><p><em>한국어나 영어, 일본어</em>처럼 사람들이 서로 의사소통하기 위해 사용하고 있는 언어들을 <strong>자연어</strong>라고 한다.<br>이와 반대되는 개념으로 <strong>인공어</strong>라는 개념이 있다. <em>인공적으로 만들어 낸 언어</em>라는 뜻이다.<br>대표적으로 에스페란토가 있고, 각종 프로그래밍 언어들도 당연히 인공어에 포함된다.  </p><p>언어는 특정한 상대와 내가 상호작용을 하기 위한 수단이다.<br>상대방과 원활히 의사소통을 하기 위해선 그 사람이 내 언어를 이해하거나, 내가 그 사람의 언어를 이해할 수 있어야 한다.<br>똑같이 한국어를 사용한다고 해도 전문 분야의 이야기라면 해당 분야의 용어를 알아야 원활히 소통할 수 있다.<br>지속적으로 공부가 필요한 이유이다.</p><p>프로그래밍 또한 거칠게 이야기 하자면 컴퓨터에게 내가 원하는 결과를 낼 수 있도록 지시하는 과정이고,<br>컴퓨터와 상호작용 하기 위해선 기계가 인간의 언어를 학습하거나 인간이 기계의 언어를 학습해야만 한다.  </p><h3 id="기계의-언어"><a href="#기계의-언어" class="headerlink" title="기계의 언어"></a>기계의 언어</h3><p>그동안 <strong>기계어</strong>를 막연히 이진수로 이루어진 기계가 이해하는 언어로만 이해하고 있었다.<br>찾아보니 틀린 말은 아니지만, 그렇다고 아주 맞는 말도 아닌 모양이다. 정확히는<br><em>CPU가 직접 이해하고 실행할 수 있는 명령 코드의 체계로, 0과 1의 나열인 비트 단위로 쓰여진 언어</em>이다.<br>따라서 CPU에 따라 각기 고유한 명령어로 구성되어 있다.  </p><p>이 기계어를 사람이 조금 더 이해하기 쉬운 형태로 변환한 것이 <strong>어셈블리어</strong>이다.<br>mov, sub, push 등 <em>일정한 의미를 가지는 단위를 단어로 변환</em>했기에 어셈블리어와 기계어는 1:1 대응이 가능하다.<br>그렇기에 어셈블리어도 기계어와 마찬가지로 CPU 종류에 따라 달라진다.  </p><p>기계어가 0과 1, 즉 전류의 흐름을 통해 시스템을 제어하는 말초적이고 추상적인 언어의 형태라면<br>어셈블리어는 논리적인 오류나 수행 과정 등을 비교적 명확히 파악할 수 있다는 점에서 좀 더 직관적인 언어이다.<br>이 부분을 깊게 파고들면 <em>컴퓨터 구조, 커널과 운영체제</em>까지 연결되는 이야기인 것 같다.  </p><p>하지만 어셈블리어가 직관적이라는 얘기도 어디까지나 기계어와 비교했을 때의 이야기이다.<br>또한 둘 다 CPU에 대해 종속성을 갖고 있기 때문에 이를 해결하기 위해 생겨난 것이 프로그래밍 언어이다.<br>여기서 저수준 언어(기계어, 어셈블리어)와 고수준 언어(흔히 쓰이는 여러 프로그래밍 언어들)를 분류하는 개념이 생기게 된다.<br>여기서 더 파고들게 되면 <em>절차적 프로그래밍 언어와 객체&#x2F;객체 지향 프로그래밍 언어</em>, 그리고 요즘 대두되는 <em>함수형 프로그래밍 언어</em>까지 시야를 넓혀 <strong>프로그래밍 방법론</strong>과 연결되는 이야기들이 된다.</p><h2 id="그래서-컴파일이-뭐라고"><a href="#그래서-컴파일이-뭐라고" class="headerlink" title="그래서 컴파일이 뭐라고?"></a>그래서 컴파일이 뭐라고?</h2><p>컴파일러는 번역기라는 비유가 많이 보인다. 즉 인간만이 이해할 수 있는 고수준 언어인 프로그래밍 언어를 기계가 받아들일 수 있도록 저수준 언어로 바꾸는 역할을 한다.<br>어셈블리어를 잘 다루지 않아 마주칠 일이 없지만 어셈블러도 비슷한 역할을 한다. 어셈블리어를 CPU가 직접적으로 이해하도록 기계어로 번역하는 역할을 한다.</p><h3 id="인터프리터"><a href="#인터프리터" class="headerlink" title="인터프리터"></a>인터프리터</h3><p>컴파일러가 컴파일을 실행할 때 여러 소스코드들을 한번에 모아서 번역하는 느낌이라면,<br>인터프리터는 코드의 각 줄을 바로바로 변환하는 느낌이다. 컴파일러를 번역에 비유한다면 인터프리터는 통역으로 비유되곤 한다.</p><h3 id="정적-언어와-동적-언어-컴파일러와-인터프리터"><a href="#정적-언어와-동적-언어-컴파일러와-인터프리터" class="headerlink" title="정적 언어와 동적 언어, 컴파일러와 인터프리터"></a>정적 언어와 동적 언어, 컴파일러와 인터프리터</h3><p>나는 그동안 정적 언어 &#x3D; 컴파일 언어 &#x2F; 동적 언어 &#x3D; 인터프리터 언어라고 알고 있었지만 이게 그대로 일치하는 개념은 아니라고 한다.<br>그래서 정적 언어이면서 인터프리터 언어인 예시나 동적 언어이면서 컴파일러 언어인 예시를 찾아보려고 했으나 딱히 뚜렷한 예를 찾을 수는 없었다.</p><h4 id="정적-언어란"><a href="#정적-언어란" class="headerlink" title="정적 언어란"></a>정적 언어란</h4><p>변수에 데이터를 할당할 때에, 자료형(데이터 타입)을 지정해주어야 하는 언어이다. C, Java, C#, Typescript 등이 있다.<br>변수를 선언할 때부터 자료형을 함께 선언해 주어야 하며, 이 자료형이 맞지 않으면 컴파일 에러가 발생한다.<br>즉 프로그램 실행 전부터 에러를 잡아내기 용이해 안정성이 높다는 장점이 있다.  </p><h4 id="동적-언어란"><a href="#동적-언어란" class="headerlink" title="동적 언어란"></a>동적 언어란</h4><p>정적 언어와 달리 변수 선언 시 해당 변수의 자료형을 지정해주지 않아도 된다.<br>코딩하는 동안 번거로움이 덜하고 정적 타입만큼 치밀하게 프로그램을 짜지 않아도 된다.(코드도 간소해지고 확실히 덜 귀찮다)<br>대표적인 언어로는 Python, Ruby, Javascript 등이 있다.<br>정적 타입과 달리 런타임에 타입 에러를 잡아내기 때문에 예기치 못한 에러를 <em>마주칠</em> 확률이 높아진다.</p><p>정적 언어와 동적 언어도 다시 강타입, 약타입으로 분류할 수 있다.<br>이런 분류에는 명시적인 기준은 없으며, 대체로 자의적인 분류인 경우가 많다.<br><img src="/asset/programming_language_static_dynamic_strong_weak_type.png" alt="graph of programming language&#39;s type"></p><h2 id="컴파일과-빌드의-차이"><a href="#컴파일과-빌드의-차이" class="headerlink" title="컴파일과 빌드의 차이?"></a>컴파일과 빌드의 차이?</h2><p><strong>빌드란, 소스코드를 실행 가능한 파일이나 배포할 수 있는 패키지로 만드는 과정</strong>을 말한다.<br>크게 보면 컴파일도 빌드에 포함되는 개념이라고 볼 수 있다.</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://cat-uni.tistory.com/42">CPU, 어셈블리 언어, 기계어, 어셈블러, 컴파일러, 링커, 로더, 커널, 쉘</a><br><a href="https://saeatechnote.tistory.com/entry/%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC-Compiler-%EC%96%B4%EC%85%88%EB%B8%94%EB%9F%AC-Assembler-%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0-Interpreter">컴파일러 Compiler &#x2F; 어셈블러 Assembler &#x2F; 인터프리터 Interpreter</a><br><a href="https://aistories.tistory.com/12">어셈블리어(Assembly) 입문자를 위한 어셈블리어 기초</a><br><a href="https://blog.naver.com/richardsky9/221013124624">프로그래밍 언어 및 컴파일러</a><br><a href="https://stackoverflow.com/questions/20926825/dynamic-static-language-and-compiler-interpreter">Dynamic&#x2F;static language and compiler&#x2F;interpreter</a><br><a href="https://ahnheejong.name/articles/types-basic-concepts/">타입과 타입 시스템 : 기본 개념</a></p>]]></content:encoded>
      
      
      <category domain="https://rvnkcode.github.io/categories/dev/">dev</category>
      
      
      <category domain="https://rvnkcode.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%96%B8%EC%96%B4%EB%A1%A0/">프로그래밍 언어론</category>
      
      <category domain="https://rvnkcode.github.io/tags/basis/">basis</category>
      
      
      <comments>https://rvnkcode.github.io/2022/04/22/3_typeSystemOfLang/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>터미널 단축키, 명령어 정리</title>
      <link>https://rvnkcode.github.io/2022/03/12/2_terminalCommand/</link>
      <guid>https://rvnkcode.github.io/2022/03/12/2_terminalCommand/</guid>
      <pubDate>Sat, 12 Mar 2022 10:47:14 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;터미널-단축키&quot;&gt;&lt;a href=&quot;#터미널-단축키&quot; class=&quot;headerlink&quot; title=&quot;터미널 단축키&quot;&gt;&lt;/a&gt;터미널 단축키&lt;/h2&gt;&lt;p&gt;iterm2 기준으로 정리했다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="터미널-단축키"><a href="#터미널-단축키" class="headerlink" title="터미널 단축키"></a>터미널 단축키</h2><p>iterm2 기준으로 정리했다.</p><span id="more"></span><table><thead><tr><th>command</th><th>action</th></tr></thead><tbody><tr><td>Ctrl+a</td><td>라인 맨 앞으로 이동</td></tr><tr><td>Ctrl+e</td><td>라인 맨 뒤로 이동</td></tr><tr><td>Ctrl+b</td><td>이전 글자로 이동</td></tr><tr><td>Ctrl+f</td><td>이후 글자로 이동</td></tr><tr><td>Ctrl+d</td><td>(입력되어 있는 글자가 있을 경우)커서 오른쪽 한 글자씩 지우기(Delete키와 동일)</td></tr><tr><td>Ctrl+w</td><td>이전 단어 삭제</td></tr><tr><td>Ctrl+u</td><td>라인 맨 처음까지 삭제</td></tr><tr><td>Ctrl+k</td><td>라인 맨 끝까지 삭제</td></tr><tr><td>Ctrl+p</td><td>직전에 입력한 명령어 보기(↑와 동일)</td></tr><tr><td>Ctrl+n</td><td>Ctrl+p의 반대(↓와 동일)</td></tr><tr><td>Ctrl+l</td><td>&#x3D; <code>clear</code></td></tr><tr><td>Ctrl+m</td><td>Enter키와 동일</td></tr><tr><td>Ctrl+c</td><td>현재 실행하고 있는 동작이나 명령을 취소</td></tr></tbody></table><h2 id="터미널-명령어"><a href="#터미널-명령어" class="headerlink" title="터미널 명령어"></a>터미널 명령어</h2><p>mac OS 터미널 명령어로 검색해서 나온 자료를 정리했는데 mac OS가 Unix 기반인지라 명령어 또한<br>리눅스 환경과 맥 환경에서 크게 차이는 없을 것 같다. {}는 변수의 의미.</p><table><thead><tr><th>command</th><th>action</th></tr></thead><tbody><tr><td><code>ls</code></td><td>현재 경로에 존재하는 파일, 폴더의 목록을 출력</td></tr><tr><td><code>pwd</code></td><td>Print Working Directory. 현재 위치한 경로를 출력</td></tr><tr><td><code>cd &#123;경로&#125;</code></td><td>Change Directory. {경로}로 이동한다.<br /> Documents, Downloads 등 경로 이름이 길다면 <code>cd Doc*, cd Dow*</code> 등으로 활용할 수 있다.</td></tr><tr><td><code>cd ..</code></td><td>상위 폴더로 이동</td></tr><tr><td><code>cd</code></td><td>Home 디렉토리로 이동</td></tr><tr><td><code>pwd</code></td><td>Print Working Directory. 현재 위치한 경로를 출력</td></tr><tr><td><code>touch &#123;파일명.확장자&#125;</code></td><td>해당하는 파일을 생성한다.</td></tr><tr><td><code>mkdir &#123;폴더명&#125;</code></td><td>make directory. 해당하는 폴더를 생성한다.</td></tr><tr><td><code>cat &#123;파일명.확장자&#125;</code></td><td>해당하는 파일의 내용을 터미널 상에 출력한다.</td></tr><tr><td><code>rm &#123;파일명.확장자&#125;</code></td><td>remove. 해당하는 파일을 삭제한다.</td></tr><tr><td><code>rmdir &#123;폴더명&#125;</code></td><td>remove directory. 해당하는 폴더가 빈 폴더일 경우 삭제한다.</td></tr><tr><td><code>rm -r &#123;폴더명&#125;</code></td><td>option: recursive. 해당하는 폴더와 그 안의 파일들까지 삭제한다.</td></tr><tr><td><code>cp &#123;복사하고 싶은 원본 파일의 경로/파일명.확장자&#125; &#123;복사할 곳의 경로/파일명.확장자&#125;</code></td><td>Copy. 해당하는 파일을 해당하는 경로에 복사한다.</td></tr><tr><td><code>mv &#123;이동하고 싶은 원본 파일의 경로/파일명.확장자&#125; &#123;이동할 곳의 경로&#125;</code></td><td>Move. 해당하는 파일을 해당하는 경로로 이동한다.</td></tr><tr><td><code>mv &#123;파일명.확장자&#125; &#123;새로운 파일명.확장자&#125;</code></td><td>해당 파일의 이름을 변경</td></tr><tr><td><code>clear</code></td><td>터미널 상에 출력되었던 모든 내용 지우기.</td></tr><tr><td><code>history</code></td><td>입력했던 명령어의 이력이 번호&#x2F;명령어 형식으로 간략하게 출력된다.<br />여기서 <code>!&#123;번호&#125; &#123;명렁어&#125;</code>형식으로 입력하면 같은 명령어를 재실행 할 수 있다.</td></tr><tr><td><code>man &#123;명령어&#125;</code></td><td>Manual. 입력한 명령어의 매뉴얼을 출력한다.</td></tr></tbody></table><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://shared.tistory.com/131">리눅스 터미널 단축키</a><br><a href="https://yozm.wishket.com/magazine/detail/746/">알아두면 유용한 맥 터미널 명령어 모음</a></p>]]></content:encoded>
      
      
      <category domain="https://rvnkcode.github.io/categories/dev/">dev</category>
      
      
      <category domain="https://rvnkcode.github.io/tags/terminal/">terminal</category>
      
      <category domain="https://rvnkcode.github.io/tags/macOS/">macOS</category>
      
      
      <comments>https://rvnkcode.github.io/2022/03/12/2_terminalCommand/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>mac OS 개발환경 구축하기</title>
      <link>https://rvnkcode.github.io/2022/02/09/1_devEnv/</link>
      <guid>https://rvnkcode.github.io/2022/02/09/1_devEnv/</guid>
      <pubDate>Wed, 09 Feb 2022 12:47:26 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;mac-mini-m1-spec&quot;&gt;&lt;a href=&quot;#mac-mini-m1-spec&quot; class=&quot;headerlink&quot; title=&quot;mac mini m1 spec&quot;&gt;&lt;/a&gt;mac mini m1 spec&lt;/h2&gt;&lt;p&gt;Mac mini(M1, 2020), 16gb memory, 512gb ssd&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="mac-mini-m1-spec"><a href="#mac-mini-m1-spec" class="headerlink" title="mac mini m1 spec"></a>mac mini m1 spec</h2><p>Mac mini(M1, 2020), 16gb memory, 512gb ssd</p><span id="more"></span><h2 id="OS-Update"><a href="#OS-Update" class="headerlink" title="OS Update"></a>OS Update</h2><h2 id="install-xcode-command-line-tools"><a href="#install-xcode-command-line-tools" class="headerlink" title="install xcode command line tools"></a>install xcode command line tools</h2><p>맥에 기본적으로 설치되어있는 터미널을 실행시킨 뒤, 적당히 git 같은 터미널 명령어를 입력한다.<br>(git이 설치되어 있지 않아도 상관 없음)<br>그러면 자동으로 팝업창이 뜨면서, Command Line Tools를 설치할 것인지 묻는데 다운로드해서 설치해주면 끝.</p><h2 id="install-Homebrew"><a href="#install-Homebrew" class="headerlink" title="install Homebrew"></a>install <a href="https://brew.sh/">Homebrew</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;</span><br></pre></td></tr></table></figure><p>솔직히 homebrew까지 설치했다면 개발환경 구축은 거의 다 끝난 것이나 다름 없다.<br>여기서부턴 brew list 해서 나온 패키지 목록들.(2022-03-25)  </p><h3 id="formulae"><a href="#formulae" class="headerlink" title="formulae"></a>formulae</h3><ul><li>bat</li><li>fzf</li><li>git</li><li>gh: GitHub on the command line  </li><li>gnupg</li><li>himalaya: email client on cli. vim 플러그인과 연동해서 간단하게 메일 확인하기에 좋다.</li><li>node</li><li>pandoc</li><li>ranger: vim inspired command line file explorer</li><li>ripgrep</li><li>tmux</li><li>trash: move files to trash in terminal. ranger와 연계해서 사용</li><li>universal-ctags: for tagbar vim plugin</li><li>vim</li><li>w3m: text-based browser</li><li>xsel: for yank from ranger to clipboard</li></ul><h3 id="casks"><a href="#casks" class="headerlink" title="casks"></a>casks</h3><ul><li>discord</li><li>iterm2</li><li>firefox</li><li>jumpcut: clipboard management tool</li><li>karabiner-elements: keyboard remapping</li><li>obsidian</li><li>raspberry-pi-imager</li><li>rectangle</li><li>slack</li><li>visual-studio-code</li><li>webstorm</li></ul><h3 id="Appstore"><a href="#Appstore" class="headerlink" title="Appstore"></a>Appstore</h3><p>2022.04.18 갱신<br>홈브류로 설치한 어플리케이션은 아니지만 앱스토어에서 설치해서 유용하게 쓰고있는 앱 목록도 함께 작성한다.</p><ul><li>spark</li><li>menubar x</li></ul><h2 id="basic-settings-on-macOS"><a href="#basic-settings-on-macOS" class="headerlink" title="basic settings on macOS"></a>basic settings on macOS</h2><p>기본적인 설정은 첫 부팅할 때 잘 해주지만(ex 로케일 설정 등…리눅스에서 건너오니 역시 이렇게 편할 수가 없었다….ㅜ) 그 외에도 소소하게 설정이 필요한 부분이 있었다. 사실 하나하나 눌러보면서 설정하면 그만인 부분들이지만 키보드 설정에서 하나를 빼먹었길래 메모해둔다.<br>키보드&gt;단축키 탭에서 하단의 <strong>키보드 탐색을 사용하여 컨트롤 간에 초점 이동</strong>에 체크.</p><h2 id="keyboard-remapping"><a href="#keyboard-remapping" class="headerlink" title="keyboard remapping"></a>keyboard remapping</h2><p>현재 사용하고 있는 키보드는 레오폴드 FC900R 스탠다드 측각 제품이다.<br>개인적으로 해피해킹 키보드 레이아웃을 좋아해서 윈도우, 리눅스, 맥 환경에서 각각 비슷하게 흉내낸 레이아웃을 리맵핑 해 사용하고 있다.<br><img src="/asset/hhkb_layout.png"><br>그냥 해피해킹을 사면 해결되는 일이지만….. 아무튼 키보드 후면의 딥스위치를 사용해 1차적으로 물리적 리맵핑을 하고,<br>나머지는 상단의 brew list에서도 볼 수 있는 karabiner를 사용하고 있다.<br>Vim을 사용하는 일이 많은데 vim은 컨트롤 키를 컨트롤 그대로 인식하기 때문에 karabiner 프로필을 Vim용과 아닌 것으로 두 개 만들었다. 차이는 cmd와 ctrl의 스위칭이 있냐 없냐의 차이 뿐이다.</p><h3 id="DIP-switch"><a href="#DIP-switch" class="headerlink" title="DIP switch"></a>DIP switch</h3><p>1번 on: LCtrl &lt;-&gt; CapsLock<br>2번 on: LAlt &lt;-&gt; Win<br>3번 off: Win &lt;-&gt; Fn<br>4번 off: kill win key  </p><h3 id="karabiner-settings"><a href="#karabiner-settings" class="headerlink" title="karabiner settings"></a>karabiner settings</h3><table><thead><tr><th>from key</th><th>to key</th></tr></thead><tbody><tr><td>application</td><td>sticky fn</td></tr><tr><td>backslash \</td><td>delete or backspace</td></tr><tr><td>caps lock</td><td>grave accent and tilde ~</td></tr><tr><td>delete or backspace</td><td>backslash \</td></tr><tr><td>escape</td><td>caps lock</td></tr><tr><td>grave accent and tilde ~</td><td>escape</td></tr><tr><td>right control</td><td>apple vendor keyboard key code language</td></tr></tbody></table><table><thead><tr><th>function keys</th><th>to key</th></tr></thead><tbody><tr><td>f3</td><td>mission control</td></tr><tr><td>f4</td><td>launchpad</td></tr><tr><td>f5</td><td>spotlight</td></tr><tr><td>f10</td><td>mute</td></tr><tr><td>f11</td><td>volume decrement</td></tr><tr><td>f12</td><td>volume increment</td></tr></tbody></table><p>결국 esc자리에 CapsLock이, 백틱 자리에 esc가, CapsLock 자리에 LCtrl이, LCtrl 자리에 백틱이 들어가게 된다.<br>백스페이스도 백슬래시와 스위칭해 이정도면 얼추 해피해킹과 비슷한 레이아웃이 아닌가 싶다.<br>재택 근무라 키보드 하나로 여러 os에 연결해 사용하기 때문에, 사소하게 다른 부분들도 있지만 esc, LCtrl, Back Space가 핵심이기 때문에 크게 불만은 없다.<br>다만 레오폴드의 fn키는, 하드웨어 단계에서 F1~F12의 키들과 조합하기 때문에 windows를 제외한 linux, mac os에서는 아예 키 입력이 인식조차 되지 않는다.<br>결국 키보드의 키 하나가 죽는 셈인데, 오른쪽 컨트롤 키를 잘 쓰지 않으니 처음에는 우클릭키와 RCtrl을 각각 fn키와 언어 변환 키(애플 키보드 보면 지구본 모양인 그 키)로 리맵핑했다.<br>다만 그렇게 리맵핑한 fn키를 누를 때마다 언어 변환도 계속 같이 되는 바람에 fn키는 결국 sticky fn으로 리맵핑하게 되었다.<br>어차피 런치패드와 mission control 외에는 펑션키들을 잘 쓰지 않기도 하고 크게 불편함은 없다.</p>]]></content:encoded>
      
      
      <category domain="https://rvnkcode.github.io/categories/dev/">dev</category>
      
      
      <category domain="https://rvnkcode.github.io/tags/homebrew/">homebrew</category>
      
      <category domain="https://rvnkcode.github.io/tags/keyboard/">keyboard</category>
      
      <category domain="https://rvnkcode.github.io/tags/remapping/">remapping</category>
      
      <category domain="https://rvnkcode.github.io/tags/setup/">setup</category>
      
      <category domain="https://rvnkcode.github.io/tags/terminal/">terminal</category>
      
      
      <comments>https://rvnkcode.github.io/2022/02/09/1_devEnv/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
