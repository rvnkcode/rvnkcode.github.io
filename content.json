{"pages":[{"title":"about","text":"그냥 편한대로 부르세요 방송국에서 구르던 짬바로 개발하기제 장래희망은요","link":"/about/index.html"}],"posts":[{"title":"mac OS 개발환경 구축하기","text":"mac mini m1 specMac mini(M1, 2020), 16gb memory, 512gb ssd OS Updateinstall xcode command line tools맥에 기본적으로 설치되어있는 터미널을 실행시킨 뒤, 적당히 git 같은 터미널 명령어를 입력한다.(git이 설치되어 있지 않아도 상관 없음)그러면 자동으로 팝업창이 뜨면서, Command Line Tools를 설치할 것인지 묻는데 다운로드해서 설치해주면 끝. install Homebrew1/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot; 솔직히 homebrew까지 설치했다면 개발환경 구축은 거의 다 끝난 것이나 다름 없다.여기서부턴 brew list 해서 나온 패키지 목록들.(2022-03-25) formulae bat fzf git gh: GitHub on the command line gnupg himalaya: email client on cli. vim 플러그인과 연동해서 간단하게 메일 확인하기에 좋다. node pandoc ranger: vim inspired command line file explorer ripgrep tmux trash: move files to trash in terminal. ranger와 연계해서 사용 universal-ctags: for tagbar vim plugin vim w3m: text-based browser xsel: for yank from ranger to clipboard casks discord iterm2 firefox jumpcut: clipboard management tool karabiner-elements: keyboard remapping obsidian raspberry-pi-imager rectangle slack visual-studio-code webstorm Appstore2022.04.18 갱신홈브류로 설치한 어플리케이션은 아니지만 앱스토어에서 설치해서 유용하게 쓰고있는 앱 목록도 함께 작성한다. spark menubar x basic settings on macOS기본적인 설정은 첫 부팅할 때 잘 해주지만(ex 로케일 설정 등…리눅스에서 건너오니 역시 이렇게 편할 수가 없었다….ㅜ) 그 외에도 소소하게 설정이 필요한 부분이 있었다. 사실 하나하나 눌러보면서 설정하면 그만인 부분들이지만 키보드 설정에서 하나를 빼먹었길래 메모해둔다.키보드&gt;단축키 탭에서 하단의 키보드 탐색을 사용하여 컨트롤 간에 초점 이동에 체크. keyboard remapping현재 사용하고 있는 키보드는 레오폴드 FC900R 스탠다드 측각 제품이다.개인적으로 해피해킹 키보드 레이아웃을 좋아해서 윈도우, 리눅스, 맥 환경에서 각각 비슷하게 흉내낸 레이아웃을 리맵핑 해 사용하고 있다.그냥 해피해킹을 사면 해결되는 일이지만….. 아무튼 키보드 후면의 딥스위치를 사용해 1차적으로 물리적 리맵핑을 하고,나머지는 상단의 brew list에서도 볼 수 있는 karabiner를 사용하고 있다.Vim을 사용하는 일이 많은데 vim은 컨트롤 키를 컨트롤 그대로 인식하기 때문에 karabiner 프로필을 Vim용과 아닌 것으로 두 개 만들었다. 차이는 cmd와 ctrl의 스위칭이 있냐 없냐의 차이 뿐이다. DIP switch1번 on: LCtrl &lt;-&gt; CapsLock2번 on: LAlt &lt;-&gt; Win3번 off: Win &lt;-&gt; Fn4번 off: kill win key karabiner settings from key to key application sticky fn backslash \\ delete or backspace caps lock grave accent and tilde ~ delete or backspace backslash \\ escape caps lock grave accent and tilde ~ escape right control apple vendor keyboard key code language function keys to key f3 mission control f4 launchpad f5 spotlight f10 mute f11 volume decrement f12 volume increment 결국 esc자리에 CapsLock이, 백틱 자리에 esc가, CapsLock 자리에 LCtrl이, LCtrl 자리에 백틱이 들어가게 된다.백스페이스도 백슬래시와 스위칭해 이정도면 얼추 해피해킹과 비슷한 레이아웃이 아닌가 싶다.재택 근무라 키보드 하나로 여러 os에 연결해 사용하기 때문에, 사소하게 다른 부분들도 있지만 esc, LCtrl, Back Space가 핵심이기 때문에 크게 불만은 없다.다만 레오폴드의 fn키는, 하드웨어 단계에서 F1~F12의 키들과 조합하기 때문에 windows를 제외한 linux, mac os에서는 아예 키 입력이 인식조차 되지 않는다.결국 키보드의 키 하나가 죽는 셈인데, 오른쪽 컨트롤 키를 잘 쓰지 않으니 처음에는 우클릭키와 RCtrl을 각각 fn키와 언어 변환 키(애플 키보드 보면 지구본 모양인 그 키)로 리맵핑했다.다만 그렇게 리맵핑한 fn키를 누를 때마다 언어 변환도 계속 같이 되는 바람에 fn키는 결국 sticky fn으로 리맵핑하게 되었다.어차피 런치패드와 mission control 외에는 펑션키들을 잘 쓰지 않기도 하고 크게 불편함은 없다.","link":"/2022/02/09/1_devEnv/"},{"title":"터미널 단축키, 명령어 정리","text":"터미널 단축키iterm2 기준으로 정리했다. command action Ctrl+a 라인 맨 앞으로 이동 Ctrl+e 라인 맨 뒤로 이동 Ctrl+b 이전 글자로 이동 Ctrl+f 이후 글자로 이동 Ctrl+d (입력되어 있는 글자가 있을 경우)커서 오른쪽 한 글자씩 지우기(Delete키와 동일) Ctrl+w 이전 단어 삭제 Ctrl+u 라인 맨 처음까지 삭제 Ctrl+k 라인 맨 끝까지 삭제 Ctrl+p 직전에 입력한 명령어 보기(↑와 동일) Ctrl+n Ctrl+p의 반대(↓와 동일) Ctrl+l = clear Ctrl+m Enter키와 동일 Ctrl+c 현재 실행하고 있는 동작이나 명령을 취소 터미널 명령어mac OS 터미널 명령어로 검색해서 나온 자료를 정리했는데 mac OS가 Unix 기반인지라 명령어 또한리눅스 환경과 맥 환경에서 크게 차이는 없을 것 같다. {}는 변수의 의미. command action ls 현재 경로에 존재하는 파일, 폴더의 목록을 출력 pwd Print Working Directory. 현재 위치한 경로를 출력 cd {경로} Change Directory. {경로}로 이동한다. Documents, Downloads 등 경로 이름이 길다면 cd Doc*, cd Dow* 등으로 활용할 수 있다. cd .. 상위 폴더로 이동 cd Home 디렉토리로 이동 pwd Print Working Directory. 현재 위치한 경로를 출력 touch {파일명.확장자} 해당하는 파일을 생성한다. mkdir {폴더명} make directory. 해당하는 폴더를 생성한다. cat {파일명.확장자} 해당하는 파일의 내용을 터미널 상에 출력한다. rm {파일명.확장자} remove. 해당하는 파일을 삭제한다. rmdir {폴더명} remove directory. 해당하는 폴더가 빈 폴더일 경우 삭제한다. rm -r {폴더명} option: recursive. 해당하는 폴더와 그 안의 파일들까지 삭제한다. cp {복사하고 싶은 원본 파일의 경로/파일명.확장자} {복사할 곳의 경로/파일명.확장자} Copy. 해당하는 파일을 해당하는 경로에 복사한다. mv {이동하고 싶은 원본 파일의 경로/파일명.확장자} {이동할 곳의 경로} Move. 해당하는 파일을 해당하는 경로로 이동한다. mv {파일명.확장자} {새로운 파일명.확장자} 해당 파일의 이름을 변경 clear 터미널 상에 출력되었던 모든 내용 지우기. history 입력했던 명령어의 이력이 번호/명령어 형식으로 간략하게 출력된다.여기서 !{번호} {명렁어}형식으로 입력하면 같은 명령어를 재실행 할 수 있다. man {명령어} Manual. 입력한 명령어의 매뉴얼을 출력한다. References리눅스 터미널 단축키알아두면 유용한 맥 터미널 명령어 모음","link":"/2022/03/12/2_terminalCommand/"},{"title":"언어의 타입 시스템과 컴파일러, 인터프리터","text":"Backstory트위터에서 공유된 차세대 빌드 도구 비교라는 글을 읽다 본문에 언급된 esbuild나 vite는 커녕컴파일과 빌드에 대한 개념, 번들러는 도대체 무슨 일을 하는 건지에 대한 이해가 없어 글을 이해할 수 없다는 걸 깨달았다.트위터에서 이런 개념들에 대해 혼자 떠들다가 결국 영상 편집은 코딩이구나! 하는 인사이트를 얻었으니 좋은 계기였다고 생각한다. 자연어, 프로그래밍 언어, 어셈블리어, 기계어 “역사가와 역사적 사실은 서로에게 필수적이다.자신의 사실을 갖지 못한 역사가는 뿌리가 없는 쓸모없는 존재다.자신의 역사가를 갖지 못한 사실은 죽은 것이며 무의미한 것이다.역사란, 역사가와 그의 사실들의 지속적인 상호작용의 과정이며, 현재와 과거의 끊임없는 대화다(a continuous process of interaction the historian and his facts, an unending dialogue between the present and the past).”『역사란 무엇인가』(E.H.Carr 저, 김택현 옮김, 까치, p.50) 사람의 언어한국어나 영어, 일본어처럼 사람들이 서로 의사소통하기 위해 사용하고 있는 언어들을 자연어라고 한다.이와 반대되는 개념으로 인공어라는 개념이 있다. 인공적으로 만들어 낸 언어라는 뜻이다.대표적으로 에스페란토가 있고, 각종 프로그래밍 언어들도 당연히 인공어에 포함된다. 언어는 특정한 상대와 내가 상호작용을 하기 위한 수단이다.상대방과 원활히 의사소통을 하기 위해선 그 사람이 내 언어를 이해하거나, 내가 그 사람의 언어를 이해할 수 있어야 한다.똑같이 한국어를 사용한다고 해도 전문 분야의 이야기라면 해당 분야의 용어를 알아야 원활히 소통할 수 있다.지속적으로 공부가 필요한 이유이다. 프로그래밍 또한 거칠게 이야기 하자면 컴퓨터에게 내가 원하는 결과를 낼 수 있도록 지시하는 과정이고,컴퓨터와 상호작용 하기 위해선 기계가 인간의 언어를 학습하거나 인간이 기계의 언어를 학습해야만 한다. 기계의 언어그동안 기계어를 막연히 이진수로 이루어진 기계가 이해하는 언어로만 이해하고 있었다.찾아보니 틀린 말은 아니지만, 그렇다고 아주 맞는 말도 아닌 모양이다. 정확히는CPU가 직접 이해하고 실행할 수 있는 명령 코드의 체계로, 0과 1의 나열인 비트 단위로 쓰여진 언어이다.따라서 CPU에 따라 각기 고유한 명령어로 구성되어 있다. 이 기계어를 사람이 조금 더 이해하기 쉬운 형태로 변환한 것이 어셈블리어이다.mov, sub, push 등 일정한 의미를 가지는 단위를 단어로 변환했기에 어셈블리어와 기계어는 1:1 대응이 가능하다.그렇기에 어셈블리어도 기계어와 마찬가지로 CPU 종류에 따라 달라진다. 기계어가 0과 1, 즉 전류의 흐름을 통해 시스템을 제어하는 말초적이고 추상적인 언어의 형태라면어셈블리어는 논리적인 오류나 수행 과정 등을 비교적 명확히 파악할 수 있다는 점에서 좀 더 직관적인 언어이다.이 부분을 깊게 파고들면 컴퓨터 구조, 커널과 운영체제까지 연결되는 이야기인 것 같다. 하지만 어셈블리어가 직관적이라는 얘기도 어디까지나 기계어와 비교했을 때의 이야기이다.또한 둘 다 CPU에 대해 종속성을 갖고 있기 때문에 이를 해결하기 위해 생겨난 것이 프로그래밍 언어이다.여기서 저수준 언어(기계어, 어셈블리어)와 고수준 언어(흔히 쓰이는 여러 프로그래밍 언어들)를 분류하는 개념이 생기게 된다.여기서 더 파고들게 되면 절차적 프로그래밍 언어와 객체/객체 지향 프로그래밍 언어, 그리고 요즘 대두되는 함수형 프로그래밍 언어까지 시야를 넓혀 프로그래밍 방법론과 연결되는 이야기들이 된다. 그래서 컴파일이 뭐라고?컴파일러는 번역기라는 비유가 많이 보인다. 즉 인간만이 이해할 수 있는 고수준 언어인 프로그래밍 언어를 기계가 받아들일 수 있도록 저수준 언어로 바꾸는 역할을 한다.어셈블리어를 잘 다루지 않아 마주칠 일이 없지만 어셈블러도 비슷한 역할을 한다. 어셈블리어를 CPU가 직접적으로 이해하도록 기계어로 번역하는 역할을 한다. 인터프리터컴파일러가 컴파일을 실행할 때 여러 소스코드들을 한번에 모아서 번역하는 느낌이라면,인터프리터는 코드의 각 줄을 바로바로 변환하는 느낌이다. 컴파일러를 번역에 비유한다면 인터프리터는 통역으로 비유되곤 한다. 정적 언어와 동적 언어, 컴파일러와 인터프리터나는 그동안 정적 언어 = 컴파일 언어 / 동적 언어 = 인터프리터 언어라고 알고 있었지만 이게 그대로 일치하는 개념은 아니라고 한다.그래서 정적 언어이면서 인터프리터 언어인 예시나 동적 언어이면서 컴파일러 언어인 예시를 찾아보려고 했으나 딱히 뚜렷한 예를 찾을 수는 없었다. 정적 언어란변수에 데이터를 할당할 때에, 자료형(데이터 타입)을 지정해주어야 하는 언어이다. C, Java, C#, Typescript 등이 있다.변수를 선언할 때부터 자료형을 함께 선언해 주어야 하며, 이 자료형이 맞지 않으면 컴파일 에러가 발생한다.즉 프로그램 실행 전부터 에러를 잡아내기 용이해 안정성이 높다는 장점이 있다. 동적 언어란정적 언어와 달리 변수 선언 시 해당 변수의 자료형을 지정해주지 않아도 된다.코딩하는 동안 번거로움이 덜하고 정적 타입만큼 치밀하게 프로그램을 짜지 않아도 된다.(코드도 간소해지고 확실히 덜 귀찮다)대표적인 언어로는 Python, Ruby, Javascript 등이 있다.정적 타입과 달리 런타임에 타입 에러를 잡아내기 때문에 예기치 못한 에러를 마주칠 확률이 높아진다. 정적 언어와 동적 언어도 다시 강타입, 약타입으로 분류할 수 있다.이런 분류에는 명시적인 기준은 없으며, 대체로 자의적인 분류인 경우가 많다. 컴파일과 빌드의 차이?빌드란, 소스코드를 실행 가능한 파일이나 배포할 수 있는 패키지로 만드는 과정을 말한다.크게 보면 컴파일도 빌드에 포함되는 개념이라고 볼 수 있다. ReferencesCPU, 어셈블리 언어, 기계어, 어셈블러, 컴파일러, 링커, 로더, 커널, 쉘컴파일러 Compiler / 어셈블러 Assembler / 인터프리터 Interpreter어셈블리어(Assembly) 입문자를 위한 어셈블리어 기초프로그래밍 언어 및 컴파일러Dynamic/static language and compiler/interpreter타입과 타입 시스템 : 기본 개념","link":"/2022/04/22/3_typeSystemOfLang/"}],"tags":[{"name":"homebrew","slug":"homebrew","link":"/tags/homebrew/"},{"name":"keyboard","slug":"keyboard","link":"/tags/keyboard/"},{"name":"remapping","slug":"remapping","link":"/tags/remapping/"},{"name":"setup","slug":"setup","link":"/tags/setup/"},{"name":"terminal","slug":"terminal","link":"/tags/terminal/"},{"name":"macOS","slug":"macOS","link":"/tags/macOS/"},{"name":"프로그래밍 언어론","slug":"프로그래밍-언어론","link":"/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%96%B8%EC%96%B4%EB%A1%A0/"},{"name":"basis","slug":"basis","link":"/tags/basis/"}],"categories":[{"name":"dev","slug":"dev","link":"/categories/dev/"}]}